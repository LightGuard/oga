%header
{
##
# DOM parser for both XML and HTML.
#
# This parser does not produce a dedicated AST, instead it emits XML nodes
# directly. Basic usage of this parser is as following:
#
#     parser   = Oga::XML::Parser.new('<foo></foo>')
#     document = parser.parse
#
# To enable HTML parsing you'd use the following instead:
#
#     parser   = Oga::XML::Parser.new('<foo></foo>', :html => true)
#     document = parser.parse
#
# In both cases you can use either a String or an IO as the parser input. IO
# instances will result in lower memory overhead, especially when parsing large
# files.
#
}

%name Oga::XML::Parser;

%terminals T_TEXT T_STRING_SQUOTE T_STRING_DQUOTE T_STRING_BODY;
%terminals T_DOCTYPE_START T_DOCTYPE_END T_DOCTYPE_TYPE T_DOCTYPE_NAME;
%terminals T_DOCTYPE_INLINE T_CDATA T_COMMENT;
%terminals T_ELEM_START T_ELEM_NAME T_ELEM_NS T_ELEM_END T_ATTR T_ATTR_NS;
%terminals T_XML_DECL_START T_XML_DECL_END;
%terminals T_PROC_INS_START T_PROC_INS_NAME T_PROC_INS_END;

document
  = expressions { on_document(val[0]) }
  | _           { on_document }
  ;

expressions
  = expression expressions { val[0] + val[1] }
  | _
  ;

expression
  = doctype
  | cdata
  | comment
  | proc_ins
  | text
  | element
  | xml_decl
  ;

# Doctypes
#
# This parses the following:
#
#     <!DOCTYPE html>
#     <!DOCTYPE html PUBLIC>
#     <!DOCTYPE html PUBLIC "foo">
#     <!DOCTYPE html PUBLIC "foo" "bar">
#     <!DOCTYPE html PUBLIC "foo" "bar">
#     <!DOCTYPE html [ ... ]>

doctype
  = T_DOCTYPE_START T_DOCTYPE_NAME doctype_follow
    {
      name   = val[1]
      follow = val[2]

      on_doctype(
        :name         => name,
        :type         => follow[0],
        :public_id    => follow[1],
        :system_id    => follow[2],
        :inline_rules => follow[3]
      )
    }
  ;

# Returns: [T_DOCTYPE_TYPE, string, string, doctype_inline]
doctype_follow
  = T_DOCTYPE_END                { [] }
  | T_DOCTYPE_TYPE doctype_types { [val[0], *val[1]] }
  | doctype_inline T_DOCTYPE_END { [nil, nil, nil, val[0]] }
  ;

doctype_inline
  = T_DOCTYPE_INLINE doctype_inline_follow { val[0] + val[1] }
  ;

doctype_inline_follow
  = doctype_inline { val[0] }
  | _              { '' }
  ;

doctype_types
  = string doctype_types_follow { [val[0], val[1]] }
  | T_DOCTYPE_END               { nil }
  ;

doctype_types_follow
  = string T_DOCTYPE_END { val[0] }
  | T_DOCTYPE_END        { nil }
  ;

# CDATA tags

cdata = T_CDATA { on_cdata(val[0]) };

# Comments

comment = T_COMMENT { on_comment(val[0]) };

# Processing Instructions

proc_ins
  = T_PROC_INS_START T_PROC_INS_NAME proc_ins_follow
    {
      on_proc_ins(val[1], val[2])
    }
  ;

proc_ins_follow
  = T_PROC_INS_END        { nil }
  | T_TEXT T_PROC_INS_END { val[0] }
  ;

# Elements

element_open = T_ELEM_START element_name_ns { val[1] };

element_name_ns
  = T_ELEM_NAME           { [nil, val[0]] }
  | T_ELEM_NS T_ELEM_NAME { val}
  ;

element_start
  = element_open attributes { on_element(val[0][0], val[0][1], val[1]) }
  ;

element
  = element_start expressions T_ELEM_END
    {
      if val[0]
        on_element_children(val[0], val[1])
      end

      after_element(val[0])
    }
  ;

# Attributes

attributes
  = attributes_ { val[0] }
  | _
  ;

attributes_
  = attribute attributes { [val[0]] + val[1] }
  | _
  ;

attribute
  = attribute_name attribute_follow
    {
      val[0].value = val[1]

      val[0]
    }
  ;

attribute_follow
  = string { val[0] }
  | _      { nil }
  ;

attribute_name
  = T_ATTR { Attribute.new(:name => val[0]) }

  | T_ATTR_NS T_ATTR
    {
      Attribute.new(:namespace_name => val[0], :name => val[1])
    }
  ;

# XML declarations

xml_decl
  = T_XML_DECL_START attributes T_XML_DECL_END
    {
      on_xml_decl(val[1])
    }
  ;

# Plain text

text = T_TEXT { on_text(val[0]) };

# Strings
#
# This parses both (empty) single and double quoted strings.

string
  = T_STRING_DQUOTE string_dquote_follow { val[1] }
  | T_STRING_SQUOTE string_squote_follow { val[1] }
  ;

string_dquote_follow
  = T_STRING_DQUOTE             { '' }
  | string_body T_STRING_DQUOTE { val[0] }
  ;

string_squote_follow
  = T_STRING_SQUOTE             { '' }
  | string_body T_STRING_SQUOTE { val[0] }
  ;

string_body
  = T_STRING_BODY string_body_follow { val[0] + val[1] }
  ;

string_body_follow
  = T_STRING_BODY string_body_follow { val[0] + val[1] }
  | _                                { '' }
  ;

%inner
{
  ##
  # @param [String|IO] data The input to parse.
  # @param [Hash] options
  # @see [Oga::XML::Lexer#initialize]
  #
  def initialize(data, options = {})
    @data  = data
    @lexer = Lexer.new(data, options)

    reset
  end

  ##
  # Resets the internal state of the parser.
  #
  def reset
    @line = 1

    @lexer.reset
  end

  ##
  # Yields the next token from the lexer.
  #
  # @yieldparam [Array]
  #
  def each_token
    @lexer.advance do |type, value, line|
      @line = line if line

      yield [type, value]
    end

    yield [-1, -1]
  end

  ##
  # @see [LL::Driver#parse]
  #
  def parse
    retval = super

    reset

    return retval
  end

  ##
  # @param [Array] children
  # @return [Oga::XML::Document]
  #
  def on_document(children = [])
    document = Document.new(:type => @lexer.html ? :html : :xml)

    children.each do |child|
      if child.is_a?(Doctype)
        document.doctype = child

      elsif child.is_a?(XmlDeclaration)
        document.xml_declaration = child

      else
        document.children << child
      end
    end

    return document
  end

  ##
  # @param [Hash] options
  #
  def on_doctype(options = {})
    return Doctype.new(options)
  end

  ##
  # @param [String] text
  # @return [Oga::XML::Cdata]
  #
  def on_cdata(text = nil)
    return Cdata.new(:text => text)
  end

  ##
  # @param [String] text
  # @return [Oga::XML::Comment]
  #
  def on_comment(text = nil)
    return Comment.new(:text => text)
  end

  ##
  # @param [String] name
  # @param [String] text
  # @return [Oga::XML::ProcessingInstruction]
  #
  def on_proc_ins(name, text = nil)
    return ProcessingInstruction.new(:name => name, :text => text)
  end

  ##
  # @param [Array] attributes
  # @return [Oga::XML::XmlDeclaration]
  #
  def on_xml_decl(attributes = [])
    options = {}

    attributes.each do |attr|
      options[attr.name.to_sym] = attr.value
    end

    return XmlDeclaration.new(options)
  end

  ##
  # @param [String] text
  # @return [Oga::XML::Text]
  #
  def on_text(text)
    return Text.new(:text => text)
  end

  ##
  # @param [String] namespace
  # @param [String] name
  # @param [Hash] attributes
  # @return [Oga::XML::Element]
  #
  def on_element(namespace, name, attributes = {})
    element = Element.new(
      :namespace_name => namespace,
      :name           => name,
      :attributes     => attributes
    )

    return element
  end

  ##
  # @param [Oga::XML::Element] element
  # @param [Array] children
  # @return [Oga::XML::Element]
  #
  def on_element_children(element, children = [])
    element.children = children

    return element
  end

  ##
  # @param [Oga::XML::Element] element
  # @return [Oga::XML::Element]
  #
  def after_element(element)
    return element
  end
}
